---
permalink: /W08/
---

**Naufal Adi Wijanarko**<br>
Operating Systems 2021-1 (Semester Genap 2020/2021)


[Home](https://naufaladi35.github.io/os211/) |
[W01](https://naufaladi35.github.io/os211/W01/) |
[W02](https://naufaladi35.github.io/os211/W02/) |
[W03](https://naufaladi35.github.io/os211/W03/) |
[W04](https://naufaladi35.github.io/os211/W04/) |
[W05](https://naufaladi35.github.io/os211/W05/) |
[W06](https://naufaladi35.github.io/os211/W06/) |
[W07](https://naufaladi35.github.io/os211/W07/) |
[W08](https://naufaladi35.github.io/os211/W08/) |
[W09](https://naufaladi35.github.io/os211/W09/) |
[W10](https://naufaladi35.github.io/os211/W10/) |
[Rank](https://naufaladi35.github.io/os211/TXT/myrank.txt) |
[LOG](https://naufaladi35.github.io/os211/TXT/mylog.txt) |
[Key](https://naufaladi35.github.io/os211/TXT/mypubkey.txt) |
[GitHub](https://github.com/naufaladi35/os211)

# Top 10 List of Week 08

1. [**Operating System - Process Scheduling**](https://www.tutorialspoint.com/operating_system/os_process_scheduling.htm)<br>
   Materi OS minggu ini mempelajari CPU Scheduling. CPU Scheduling mempunyai tujuan untuk meningkatkan kinerja sistem sesuai dengan kriteria yang dipilih. CPU Scheduling memilih proses di antara proses yang siap untuk dieksekusi dan mengalokasikan CPU ke salah satunya. Penjelasan dari website ini cukup singkat dan dilengkapi diagram yang membantu saya untuk memahami.

2. [**Preemptive Scheduling**](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/)<br>
   Preemptive Scheduling digunakna ketika proses beralih dari running state ke ready state atau dari waiting stateke ready state. Resource dialokasikan ke proses tertentu selama waktu tertentu, lalu dikembalikan ke ready queue.

3. [**Multiprocessor Scheduling in Operating System**](https://www.includehelp.com/operating-systems/multiprocessor-scheduling-in-operating-system.aspx)<br>
   Multi Processor Scheduling terdiri dari beberapa CPU yang saling membagi beban sehingga proses berjalan bersamaan. Dalam Multi Processor Scheduling, suatu memopry digunakan oleh beberapa CPU. Untuk lebih lengkapnya, dapat dibaca pada website tersebut.

4. [**CPU Burst**](http://www2.cs.uregina.ca/~hamilton/courses/330/notes/scheduling/scheduling.html#:~:text=CPU%20burst%3A%20the%20amount%20of,it%20is%20no%20longer%20ready)
   CPU burst adalah banyak waktu yang dibutuhkan sebuah proses terhadap prosessor hingga proses tersebut tidak siap lagi. Menurut saya, tampilan dari website ini kurang menarik tapi penjelasannya cukup.

5. [**I/O Burst**](https://www.quora.com/What-is-meant-by-CPU-Burst-and-I-O-Burst)<br>
   I/O burst adalah yaitu ketika sebuah proses sedang berada di running state, maka proses tersebut akan meminta I/O sehingga ketika proses tersebut meminta, maka proses tersebut berada di mode menunggu hingga I/O diterima, baru kembali ke ready state. Terdapat beberapa jawaban dalam link ini, tapi menurut saya jawaban ini paling jelas.

6. [**Dispathcer dan Tipe Scheduler**](https://www.geeksforgeeks.org/difference-between-dispatcher-and-scheduler/)<br>
   Dispacther adalah sebuah program spesial di mana akan mulai dieksekusi ketika scheduler selesai dieksekusi. Ada tiga macam scheduler, yaitu long term, medium term, dan short term. Penjelasannya mudah dimengerti dan perbedaannya diberikan secara jelas.

7. [**Deadline Scheduling for Real-Time Systems**](https://study.com/academy/lesson/deadline-scheduling-for-real-time-systems.html)<br>
    Setelah membaca tentang scheduling di slide OS, saya coba GSGS dan menemukan website ini. Website ini menjelaskan tentang Deadline Scheduling beserta jenis dan prosesnya, antara lain Static, Dynamic, Preemptive, dan Non-preemptive. 

8. [**Perbandingan antara Algoritma Scheduling**](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/)<br>
   Artikel dari GeeksForGeeks ini menjelaskan kelebihan dan kekurangan antar algoritma scheduling. Misalnya, algoritma FCFS dapat menyebabkan waiting time yang panjang jika process pertama memakan waktu lama. Untuk lebih lengkapnya dapat dibaca di website tersebut.

9. [**Convoy Effect in Operating Systems**](https://www.geeksforgeeks.org/convoy-effect-operating-systems/)<br>
   Convoy Effect adalah suatu fenomena yang terjadi dalam algoritma FCFS, dimana beberapa process yag lambat menghambat seluruh proses. Website ini menjelaskan apa itu Convoy Effect dan prosesiterjadinya Convoy Effect dengan jelas dan singkat.

10. [**Difference between Hard real time and Soft real time system**](https://www.geeksforgeeks.org/difference-between-hard-real-time-and-soft-real-time-system/)<br>
   Pada hard real time, jika tidak berhasil memenuhi deadline maka proses akan gagal. Sementara, pada soft real time, performance akan berkurang tapi proses akan tetap berjalan. Untuk lebih jelasnya, dapat dibaca di website tersebut.
